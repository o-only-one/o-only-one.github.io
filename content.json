{"pages":[],"posts":[{"title":"DOS中进入盘符和文件夹","text":"在DOS中如何进入盘符和文件夹之前都是用快捷键直接在对应目录下 shift+鼠标右键 来打开命令窗口，公司给换了主机，发现shift+鼠标右键选择只有 Powershell ,一方面是想如何通过命令进入指定盘符和文件夹，另一个方面看习惯了DOS的窗口，突然打开 Powershell 的有些不习惯，碍于自己是个伪程序员，所以有必要向无所不能的程序员奋斗，因此在网上搜罗了一番。 快捷键win + R,打开运行面板，输入 cmd ,然后’确定’。 进入dos后，输入要进入的盘符。 如要进入D盘，则输入d:回车即可。 如若要进入D盘对应文件夹web下边的css文件夹，输入cd web\\css回车。 回到上级目录的命令是cd..。 如何使用dos命令删除文件夹和文件 删除文件可以直接进入文件对应的位置，然后通过del 文件名删除； 删除文件夹以及文件夹的内容rd/s/q 盘符名:\\文件夹名 删除空的文件夹:rd 盘符名:\\文件夹名","link":"/2019/07/19/2019-07-19-1/"},{"title":"为什么用Object.prototype.toString.call(obj)去检测类型？","text":"为什么用Object.prototype.toString.call(obj)去检测类型？在看vue的发布者-订阅者模式的时候看到这么一句代码（无注释） 1if(Object.prototype.toString.call(callback) !== '[object Function]') return 一点都不明白所要表达的意思，然后就问了下度娘，发现这段代码其实是为了检测传入数据的类型，我们平时检测类型不是用typeOf就是instanceof操作符，详细了解这个方式之后，觉得也是有其优势的，因为null的typeof是object，array的结果也是object，而有时候我们需要的是纯粹的object。 1console.log(Object.prototype.toString.call(obj) === '[object Object]'); 使用以上方式可以很好的区分各种类型：(无法区分自定义对象类型，自定义类型可以采用instanceof区分) 123456789101112console.log(Object.prototype.toString.call(\"jerry\")); //[object String]console.log(Object.prototype.toString.call(12)); //[object Number]console.log(Object.prototype.toString.call(true)); //[object Boolean]console.log(Object.prototype.toString.call(undefined)); //[object Undefined]console.log(Object.prototype.toString.call(null)); //[object Null]console.log(Object.prototype.toString.call({name:\"jerry\"})) //[object Object]console.log(Object.prototype.toString.call(function (){})) //[object Function]console.log(Object.prototype.toString.call([])) //[obejct Array]console.log(Object.prototype.toString.call(new Date)) //[object Date]console.log(Object.prototype.toString.call(/\\d/)) //[object RegExp]function Person(){};console.log(Object.prototype.toString.call(new Person())) //[object Object] 为什么这样区分呢？ toString方法返回反映这个对象的字符串那为什么不直接用objec.toString() 1234567console.log(\"jerry\".toString()); //jerryconsole.log((1).toString()); //1console.log([1,2].toString()); //1,2console.log(new Date().toString()); //Thu Jun 27 2019 11:04:25 GMT+0800 (中国标准时间)console.log(function(){}.toString()); //function(){}console.log(null.toString()); //errorconsole.log(undefined.toString()); //error obj.toString()和Object.prototype.toString.call(obj)的结果不一样，这是为什么？这是因为toString为Object的原型方法，而Array、Function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（FUnction返回函数体的字符串，Array返回元素组成的字符串），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，想要得到对象的具体类型时，应该调用Object上原型toString方法。 我们可以验证一下，将数组的toString方法删除，看看会是什么结果： 123456var arr = [1,2,3];console.log(Array.prototype.hasOwnProperty(\"toString\")); //trueconsole.log(arr.toString()); //1,2,3delete Array.prototype.toString; //delete方法可以删除实例属性console.log(Array.prototype.hasOwnProperty(\"toString\")); //falseconsole.log(arr.toString()); //[object Array] 删除了Array的toString方法后，同样采用arr.toString方法调用，不在有屏蔽Object原型方法的实例方法，因此沿着原型链，arr最后调用了Object的toString方法，返回了和Object.prototype.toString.call(obj)相同的结果。","link":"/2019/07/19/2019-07-19-2/"},{"title":"github克隆项目到本地","text":"新手安装git之后如何clone我们在github上看到的项目之前在公司安装了git，由于临时换了电脑重新安装git，突然发现git clone url报错 权限被拒绝(publickey) 无法从远程库读取 所以思考是不是没有创建SSH Key。接着我就按照网上的方式找到了用户目录下的.ssh的文件夹，发现里面没有id_rsa和id_rsa.pub这两个文件；既然没有这个文件，我自然是需要创建的 首先,在打开git bash 并且输入ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 这里的youremail@example.com指的是我们自己的邮箱 然后我们会发现c盘（我的是c盘）administrator下生成了.ssh文件夹，并且里面对应有id_rsa和id_rsa.pub两个文件，如下图： 将id_rsa.pub用记事本打开并且复制内容到剪切板 登录github账号，点击右上角小图标下拉setting 跳转页面之后点击左侧SSH and GPG keys 点击New SSH key按钮，然后填上自己命名的Title key下面的文本域就给我们之前复制的内容粘贴到里面，然后Add SSH key就完成了","link":"/2019/07/19/2019-07-19/"}],"tags":[],"categories":[]}